"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.next = void 0;
var common_1 = require("./common");
var iter;
var findOnce = function (parsed, from) {
    if (iter > 10) {
        throw new Error("AwsCronParser : this shouldn't happen, but iter > 10");
    }
    iter += 1;
    var cYear = from.getUTCFullYear();
    var cMonth = from.getUTCMonth() + 1;
    var cDayOfMonth = from.getUTCDate();
    var cHour = from.getUTCHours();
    var cMinute = from.getUTCMinutes();
    var year = common_1.arrayFindFirst(parsed.years, function (c) { return c >= cYear; });
    if (!year) {
        return null;
    }
    var month = common_1.arrayFindFirst(parsed.months, function (c) { return c >= (year === cYear ? cMonth : 1); });
    if (!month) {
        return findOnce(parsed, new Date(Date.UTC(year + 1, 0)));
    }
    var isSameMonth = year === cYear && month === cMonth;
    var pDaysOfMonth = parsed.daysOfMonth;
    if (pDaysOfMonth.length === 0) {
        pDaysOfMonth = common_1.getDaysOfMonthFromDaysOfWeek(year, month, parsed.daysOfWeek);
    }
    else if (pDaysOfMonth[0] === 'L') {
        pDaysOfMonth = common_1.getDaysOfMonthForL(year, month, pDaysOfMonth[1]);
    }
    else if (pDaysOfMonth[0] === 'W') {
        pDaysOfMonth = common_1.getDaysOfMonthForW(year, month, pDaysOfMonth[1]);
    }
    var dayOfMonth = common_1.arrayFindFirst(pDaysOfMonth, function (c) { return c >= (isSameMonth ? cDayOfMonth : 1); });
    if (!dayOfMonth) {
        return findOnce(parsed, new Date(Date.UTC(year, month + 1 - 1)));
    }
    var isSameDate = isSameMonth && dayOfMonth === cDayOfMonth;
    var hour = common_1.arrayFindFirst(parsed.hours, function (c) { return c >= (isSameDate ? cHour : 0); });
    if (typeof hour === 'undefined') {
        return findOnce(parsed, new Date(Date.UTC(year, month - 1, dayOfMonth + 1)));
    }
    var minute = common_1.arrayFindFirst(parsed.minutes, function (c) { return c >= (isSameDate && hour === cHour ? cMinute : 0); });
    if (typeof minute === 'undefined') {
        return findOnce(parsed, new Date(Date.UTC(year, month - 1, dayOfMonth, hour + 1)));
    }
    return new Date(Date.UTC(year, month - 1, dayOfMonth, hour, minute));
};
/**
 * generate the next occurrence AFTER the "from" date value
 * returns NULL when there is no more future occurrence
 * @param {*} parsed the value returned by "parse" function of this module
 * @param {*} from the Date to start from
 */
function next(parsed, from) {
    // iter is just a safety net to prevent infinite recursive calls
    // because I'm not 100% sure this won't happen
    iter = 0;
    return findOnce(parsed, new Date((Math.floor(from.getTime() / 60000) + 1) * 60000));
}
exports.next = next;
//# sourceMappingURL=next.js.map