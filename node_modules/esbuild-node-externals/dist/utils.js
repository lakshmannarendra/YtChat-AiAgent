"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDependencies = exports.findPackagePaths = exports.createAllowPredicate = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = __importDefault(require("node:fs"));
const find_up_1 = __importDefault(require("find-up"));
const createAllowPredicate = (allowList) => {
    return typeof allowList === 'function'
        ? allowList
        : (path) => Boolean(allowList.find((pattern) => typeof pattern === 'string' ? path === pattern : pattern.test(path)));
};
exports.createAllowPredicate = createAllowPredicate;
/**
 * Determines if the `child` path is under the `parent` path.
 */
const isInDirectory = (parent, child) => {
    const relativePath = node_path_1.default.relative(parent, child);
    return !relativePath.startsWith('..') && !node_path_1.default.isAbsolute(relativePath);
};
const isInGitDirectory = (path, gitRootPath) => {
    return gitRootPath === undefined || isInDirectory(gitRootPath, path);
};
/**
 * Iterates over package.json file paths recursively found in parent directories, starting from the
 * current working directory. If the current working directory is in a git repository, then package.json
 * files outside of the git repository will not be yielded.
 * Inspired by https://github.com/Septh/rollup-plugin-node-externals/blob/f13ee95c6f1f01d8ba2276bf491aac399adc5482/src/dependencies.ts#L18
 */
const findPackagePaths = (_cwd = process.cwd()) => {
    // Find git root if in git repository
    const gitDirectoryPath = find_up_1.default.sync('.git', {
        type: 'directory',
        cwd: _cwd,
    });
    const gitRootPath = gitDirectoryPath === undefined ? undefined : node_path_1.default.dirname(gitDirectoryPath);
    let cwd = _cwd;
    let packagePath;
    const packagePaths = [];
    while ((packagePath = find_up_1.default.sync('package.json', { type: 'file', cwd })) &&
        isInGitDirectory(packagePath, gitRootPath)) {
        packagePaths.push(packagePath);
        cwd = node_path_1.default.dirname(node_path_1.default.dirname(packagePath));
    }
    return packagePaths;
};
exports.findPackagePaths = findPackagePaths;
function getDependencyKeys(map = {}, allowWorkspaces = false) {
    if (!map) {
        return [];
    }
    if (!allowWorkspaces) {
        return Object.keys(map);
    }
    // Filter out shared workspaces
    return Object.keys(map).filter((depKey) => !map[depKey]?.startsWith('workspace:'));
}
/**
 * Return an array of the package.json dependencies that should be excluded from the build.
 */
const findDependencies = (options) => {
    const packageJsonKeys = [
        options.dependencies && 'dependencies',
        options.devDependencies && 'devDependencies',
        options.peerDependencies && 'peerDependencies',
        options.optionalDependencies && 'optionalDependencies',
    ].filter(Boolean);
    const data = options.packagePaths.map((packagePath) => {
        let packageJson;
        try {
            const packageJsonString = node_fs_1.default.readFileSync(packagePath, 'utf8');
            packageJson = JSON.parse(packageJsonString);
        }
        catch (error) {
            console.error(error);
            throw new Error(`Couldn't process ${packagePath}". Make sure it's a valid JSON.`);
        }
        const packageNames = packageJsonKeys
            .map((key) => getDependencyKeys(packageJson[key], options.allowWorkspaces))
            .flat(1);
        const { allowPredicate } = options;
        return allowPredicate
            ? packageNames.filter((packageName) => !allowPredicate(packageName))
            : packageNames;
    });
    return data.flat(1);
};
exports.findDependencies = findDependencies;
//# sourceMappingURL=utils.js.map