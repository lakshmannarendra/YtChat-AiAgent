import { $ } from "execa";
export default class PoetryPackageManager {
    constructor() {
        this.command = "poetry";
    }
    async install(packages = [], cwd, _args) {
        if (packages.length > 0) {
            await $({ cwd }) `poetry add ${packages.join(" ")}`;
        }
        else {
            await $({ cwd }) `poetry install`;
        }
    }
    async cleanInstall(cwd, args) {
        await $({ cwd }) `poetry install ${args ?? []}`;
    }
    installSync(packages = [], cwd) {
        if (packages.length > 0) {
            $({ cwd }).sync `poetry add ${packages.join(" ")}`;
        }
        else {
            $({ cwd }).sync `poetry install`;
        }
    }
    async link(packages = [], cwd) {
        for (const pkg of packages) {
            await $({ cwd }) `poetry add ${pkg} --editable`;
        }
    }
    // TODO Implement publish when we support it
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async publish(cwd) {
        return;
    }
    // TODO Implement addScopedRegistry and removeScopedRegistry when we support it
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async addScopedRegistry(url, authToken) {
        return;
    }
    async removeScopedRegistry() {
        return;
    }
    async getVersion() {
        if (this.version !== undefined) {
            return this.version;
        }
        const { stdout } = await $ `poetry --version`;
        this.version = stdout.split(" ")[1].trim();
        return this.version;
    }
    async pack(cwd, destination) {
        await $({ cwd }) `poetry build`;
        const { stdout } = await $({ cwd }) `ls ${destination}`;
        return stdout.trim();
    }
}
