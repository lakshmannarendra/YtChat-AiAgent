var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AstGenerator_instances, _AstGenerator_compileGenezioGoAstExtractor;
import path from "path";
import os from "os";
import fs from "fs";
import { log } from "../../utils/logging.js";
import { AstNodeType, MethodKindEnum, SourceType, } from "../../models/genezioModels.js";
import { runNewProcess } from "../../utils/process.js";
import { checkIfGoIsInstalled } from "../../utils/go.js";
import { createTemporaryFolder } from "../../utils/file.js";
import { UserError } from "../../errors.js";
import { $ } from "execa";
const releaseTag = "v0.1.2";
const binaryName = `golang_ast_generator_${releaseTag}`;
export class AstGenerator {
    constructor() {
        _AstGenerator_instances.add(this);
    }
    async generateAst(input) {
        // Check if Go is installed
        checkIfGoIsInstalled();
        // Check if the go ast generator is compiled
        const goAstGeneratorPath = path.join(os.homedir(), ".genezio", ".golang_ast_generator", binaryName);
        if (!fs.existsSync(goAstGeneratorPath)) {
            await __classPrivateFieldGet(this, _AstGenerator_instances, "m", _AstGenerator_compileGenezioGoAstExtractor).call(this);
        }
        const classAbsolutePath = path.resolve(input.class.path);
        const result = await $({
            cwd: input.root,
        }) `${goAstGeneratorPath} ${classAbsolutePath}`.catch((error) => {
            log.error(error.stderr);
            throw new UserError("Error: Failed to generate AST for class " + input.class.path);
        });
        const ast = JSON.parse(result.stdout);
        const error = ast.error;
        if (error) {
            if (ast.file && ast.line && ast.column) {
                log.error(new Error(`${error} at ${ast.file}:${ast.line}:${ast.column}`));
            }
            else {
                log.error(error);
            }
            throw new UserError("Error: Failed to generate AST for class " + input.class.path);
        }
        const goAstBody = ast.body;
        if (!goAstBody) {
            throw new UserError("Error: Failed to generate AST for class " + input.class.path);
        }
        const body = [];
        for (const astNode of goAstBody) {
            if (astNode.type == AstNodeType.ClassDefinition) {
                const classDefinition = {
                    type: AstNodeType.ClassDefinition,
                    name: astNode.name,
                    path: astNode.path,
                    docString: astNode.docString,
                    methods: [],
                };
                for (const method of astNode.methods) {
                    const methodDefinition = {
                        type: AstNodeType.MethodDefinition,
                        name: method.name,
                        params: [],
                        kind: MethodKindEnum.method,
                        static: false,
                        docString: method.docString,
                        returnType: method.returnType,
                    };
                    for (const param of method.params) {
                        methodDefinition.params.push({
                            type: AstNodeType.ParameterDefinition,
                            name: param.name,
                            optional: param.optional,
                            rawType: param.rawType,
                            paramType: param.paramType,
                        });
                    }
                    classDefinition.methods.push(methodDefinition);
                }
                body.push(classDefinition);
            }
            else {
                switch (astNode.type) {
                    case AstNodeType.StructLiteral: {
                        const structLiteral = {
                            type: AstNodeType.StructLiteral,
                            name: astNode.name,
                            path: astNode.path,
                            typeLiteral: astNode.typeLiteral,
                        };
                        body.push(structLiteral);
                        break;
                    }
                }
            }
        }
        return {
            program: {
                body,
                originalLanguage: "go",
                sourceType: SourceType.module,
            },
        };
    }
}
_AstGenerator_instances = new WeakSet(), _AstGenerator_compileGenezioGoAstExtractor = async function _AstGenerator_compileGenezioGoAstExtractor() {
    const folder = await createTemporaryFolder();
    const astClone = await runNewProcess("git clone --quiet https://github.com/Genez-io/go-ast.git .", folder);
    if (!astClone) {
        throw new UserError("Error: Failed to clone Go AST parser repository to " +
            folder +
            " temporary folder!");
    }
    await runNewProcess(`git checkout --quiet tags/${releaseTag}`, folder);
    const goBuildSuccess = await runNewProcess(`go build -o ${binaryName} cmd/main.go`, folder);
    if (!goBuildSuccess) {
        throw new UserError("Error: Failed to build Go AST parser in " + folder + " temporary folder!");
    }
    if (!fs.existsSync(path.join(os.homedir(), ".genezio", ".golang_ast_generator"))) {
        fs.mkdirSync(path.join(os.homedir(), ".genezio", ".golang_ast_generator"));
    }
    const goAstGeneratorPath = path.join(folder, binaryName);
    const goAstGeneratorPathInHome = path.join(os.homedir(), ".genezio", ".golang_ast_generator", binaryName);
    fs.copyFileSync(goAstGeneratorPath, goAstGeneratorPathInHome);
};
const supportedExtensions = ["go"];
export default { supportedExtensions, AstGenerator };
