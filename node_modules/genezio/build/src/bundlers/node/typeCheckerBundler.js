var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TypeCheckerBundler_instances, _TypeCheckerBundler_generateTsconfigJson;
import ts from "typescript";
import { log } from "../../utils/logging.js";
import fs from "fs";
import { tsconfig } from "../../utils/configs.js";
import path from "path";
import { writeToFile } from "../../utils/file.js";
import { debugLogger } from "../../utils/logging.js";
import { UserError } from "../../errors.js";
export class TypeCheckerBundler {
    constructor() {
        _TypeCheckerBundler_instances.add(this);
    }
    static logChangeDetection() {
        TypeCheckerBundler.used = false;
    }
    async bundle(input) {
        if (TypeCheckerBundler.used) {
            return input;
        }
        TypeCheckerBundler.used = true;
        const cwd = input.projectConfiguration.workspace?.backend || process.cwd();
        await __classPrivateFieldGet(this, _TypeCheckerBundler_instances, "m", _TypeCheckerBundler_generateTsconfigJson).call(this, cwd);
        const configPath = path.join(cwd, "tsconfig.json");
        const config = ts.getParsedCommandLineOfConfigFile(configPath, undefined, {
            ...ts.sys,
            onUnRecoverableConfigFileDiagnostic: () => { },
        });
        if (!config) {
            throw new UserError("Failed to parse tsconfig.json");
        }
        const program = ts.createProgram({
            rootNames: config.fileNames,
            options: config.options,
        });
        debugLogger.debug("Typechecking Typescript files...");
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length > 0) {
            diagnostics.forEach((diagnostic) => {
                if (diagnostic.category === ts.DiagnosticCategory.Error) {
                    // Format the diagnostic and write it to stderr
                    log.error(ts.formatDiagnostic(diagnostic, {
                        getCanonicalFileName: (fileName) => fileName,
                        getCurrentDirectory: ts.sys.getCurrentDirectory,
                        getNewLine: () => ts.sys.newLine,
                    }));
                }
            });
            throw new UserError("Typescript compilation failed.");
        }
        return input;
    }
}
_TypeCheckerBundler_instances = new WeakSet(), _TypeCheckerBundler_generateTsconfigJson = async function _TypeCheckerBundler_generateTsconfigJson(cwd) {
    if (fs.existsSync(path.join(cwd, "tsconfig.json"))) {
        return;
    }
    else {
        log.info("No tsconfig.json file found. We will create one...");
        tsconfig.compilerOptions.rootDir = ".";
        tsconfig.compilerOptions.outDir = path.join(".", "build");
        tsconfig.include = [path.join(".", "**/*")];
        await writeToFile(cwd, "tsconfig.json", JSON.stringify(tsconfig, null, 4));
    }
};
// Call this class only once
TypeCheckerBundler.used = false;
