var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DartBundler_instances, _DartBundler_analyze, _DartBundler_castParameterToPropertyType, _DartBundler_getProperCast, _DartBundler_createRouterFileForClass, _DartBundler_compile;
import path from "path";
import Mustache from "mustache";
import { createTemporaryFolder, deleteFolder, writeToFile } from "../../utils/file.js";
import { checkIfDartIsInstalled } from "../../utils/dart.js";
import { debugLogger } from "../../utils/logging.js";
import { template } from "./localDartMain.js";
import { default as fsExtra } from "fs-extra";
import { spawnSync } from "child_process";
import { TriggerType } from "../../projectConfiguration/yaml/models.js";
import { log } from "../../utils/logging.js";
import { AstNodeType, } from "../../models/genezioModels.js";
import { castArrayRecursivelyInitial, castMapRecursivelyInitial, } from "../../utils/dartAstCasting.js";
import { UserError } from "../../errors.js";
export class DartBundler {
    constructor() {
        _DartBundler_instances.add(this);
    }
    async bundle(input) {
        // Create a temporary folder were we copy user code to prepare everything.
        const folderPath = input.genezioConfigurationFilePath;
        const inputTemporaryFolder = await createTemporaryFolder();
        await fsExtra.copy(folderPath, inputTemporaryFolder);
        debugLogger.info(`Copy files in temp folder ${inputTemporaryFolder}`);
        // Create the router class
        const userClass = input.projectConfiguration.classes.find((c) => c.path == input.path);
        await __classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_createRouterFileForClass).call(this, userClass, input.ast, inputTemporaryFolder);
        // Check if dart is installed
        await checkIfDartIsInstalled();
        // Analyze the Dart code on the server
        await __classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_analyze).call(this, inputTemporaryFolder);
        // Compile the Dart code on the server
        debugLogger.info("Compiling Dart...");
        await __classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_compile).call(this, inputTemporaryFolder);
        debugLogger.info("Compiling Dart finished.");
        return {
            ...input,
            path: inputTemporaryFolder,
            extra: {
                ...input.extra,
                startingCommand: path.join(inputTemporaryFolder, "main.exe"),
                commandParameters: [],
            },
        };
    }
}
_DartBundler_instances = new WeakSet(), _DartBundler_analyze = async function _DartBundler_analyze(path) {
    const result = spawnSync("dart", ["analyze", "--no-fatal-warnings"], {
        cwd: path,
    });
    if (result.status != 0) {
        log.info(result.stdout.toString().split("\n").slice(1).join("\n"));
        // Delete the temporary folder if the compilation fails
        await deleteFolder(path);
        throw new UserError("Compilation error! Please check your code and try again.");
    }
}, _DartBundler_castParameterToPropertyType = function _DartBundler_castParameterToPropertyType(node, variableName) {
    let implementation = "";
    switch (node.type) {
        case AstNodeType.StringLiteral:
            implementation += `${variableName} as String`;
            break;
        case AstNodeType.DoubleLiteral:
            implementation += `${variableName} as double`;
            break;
        case AstNodeType.BooleanLiteral:
            implementation += `${variableName} as bool`;
            break;
        case AstNodeType.IntegerLiteral:
            implementation += `${variableName} as int`;
            break;
        case AstNodeType.PromiseType:
            implementation += __classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_castParameterToPropertyType).call(this, node.generic, variableName);
            break;
        case AstNodeType.CustomNodeLiteral:
            implementation += `${node.rawValue}.fromJson(${variableName} as Map<String, dynamic>)`;
            break;
        case AstNodeType.ArrayType:
            implementation += castArrayRecursivelyInitial(node, variableName);
            break;
        case AstNodeType.MapType:
            implementation += castMapRecursivelyInitial(node, variableName);
    }
    return implementation;
}, _DartBundler_getProperCast = function _DartBundler_getProperCast(mainClass, method, parameterType, index) {
    const type = mainClass.methods
        .find((m) => m.name == method.name)
        .params.find((p) => p.name == parameterType.name);
    return `${__classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_castParameterToPropertyType).call(this, type.paramType, `params[${index}]`)}`;
}, _DartBundler_createRouterFileForClass = async function _DartBundler_createRouterFileForClass(classConfiguration, ast, folderPath) {
    const mainClass = ast.body?.find((element) => {
        return (element.type === AstNodeType.ClassDefinition &&
            element.name === classConfiguration.name);
    });
    const moustacheViewForMain = {
        classFileName: path.basename(classConfiguration.path, path.extname(classConfiguration.path)),
        className: classConfiguration.name,
        jsonRpcMethods: classConfiguration.methods
            .filter((m) => m.type === TriggerType.jsonrpc)
            .map((m) => ({
            name: m.name,
            parameters: m.parameters.map((p, index) => ({
                index,
                cast: __classPrivateFieldGet(this, _DartBundler_instances, "m", _DartBundler_getProperCast).call(this, mainClass, m, p, index),
            })),
        })),
        cronMethods: classConfiguration.methods
            .filter((m) => m.type === TriggerType.cron)
            .map((m) => ({
            name: m.name,
        })),
        httpMethods: classConfiguration.methods
            .filter((m) => m.type === TriggerType.http)
            .map((m) => ({
            name: m.name,
        })),
        imports: ast.body?.map((element) => ({ name: element.path })),
    };
    const routerFileContent = Mustache.render(template, moustacheViewForMain);
    await writeToFile(folderPath, "main.dart", routerFileContent);
}, _DartBundler_compile = async function _DartBundler_compile(folderPath) {
    const result = spawnSync("dart", ["compile", "exe", "main.dart"], {
        cwd: folderPath,
    });
    if (result.status != 0) {
        log.info(result.stderr.toString());
        log.info(result.stdout.toString());
        // Delete the temporary folder if the compilation fails
        await deleteFolder(folderPath);
        throw new UserError("Compilation error! Please check your code and try again.");
    }
};
