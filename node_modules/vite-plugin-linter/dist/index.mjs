import { createFilter } from '@rollup/pluginutils';
import { r as readAllFiles, n as normalizePath, l as linterPluginBuild, o as onlyUnique } from './shared/vite-plugin-linter.6c199188.mjs';
import { watch } from 'chokidar';
import fs from 'fs';
import path from 'path';
import { createWorkerThreads } from './lintWorkerThread.mjs';
import { ESLint, loadESLint } from 'eslint';
import ts from 'typescript';
import 'url';
import 'vite';
import 'worker_threads';

const servePluginName = "vite-plugin-linter-serve";
const clientEventName = "eslint-warn";
const clientJs = `
  if (import.meta.hot) {
    fetch("/eslint.json")
      .then(r => r.json())
      .then(response => {
        if (response) {
          for (let line of response) {
            console.warn(line);
          }
        }
      })
      .catch(e => console.error(e));

    import.meta.hot.on("${clientEventName}", d => console.warn(d));
  }
`;
function linterPluginServe(options = {}, fileFilter) {
  let devServer = null;
  const includeMode = options.serve?.includeMode ?? "processedFiles";
  let injectedFile = null;
  let lintFiles = [];
  let processingTimeout;
  let workersByLinterName = {};
  let dataByFileNameByLinterName = {};
  for (const linter of options.linters) {
    dataByFileNameByLinterName[linter.name] = {};
  }
  async function getFormattedOutput(linter) {
    const dataByFileName = dataByFileNameByLinterName[linter.name];
    const allData = [];
    for (const file of Object.keys(dataByFileName)) {
      allData.push(dataByFileName[file]);
    }
    if (allData.length > 0) {
      return await linter.format(allData);
    }
    return "";
  }
  async function onWorkerMessage(message, pluginContext) {
    const dataByFileName = dataByFileNameByLinterName[message.linterName];
    for (const file of message.files) {
      if (file in message.result.serve) {
        dataByFileName[file] = message.result.serve[file];
      } else if (file in dataByFileName) {
        delete dataByFileName[file];
      }
    }
    const linter = options.linters.find((l) => l.name === message.linterName);
    const output = await getFormattedOutput(linter);
    if (output) {
      pluginContext.warn(output);
      if (devServer) {
        devServer.ws.send({
          event: clientEventName,
          data: output,
          type: "custom"
        });
      }
    }
  }
  async function processFiles() {
    const files = [...lintFiles];
    if (includeMode !== "filesInFolder") {
      lintFiles = [];
    }
    for (const linter of options.linters) {
      workersByLinterName[linter.name].postMessage(files);
    }
  }
  function watchDirectory(directory) {
    function onChange(fsPath) {
      const normalizedPath = normalizePath(fsPath);
      let changed = false;
      if (fileFilter(fsPath)) {
        if (includeMode === "filesInFolder" && !lintFiles.includes(normalizedPath)) {
          lintFiles.push(normalizedPath);
        }
        changed = true;
      } else if (fs.existsSync(fsPath) && fs.lstatSync(fsPath).isDirectory()) {
        const children = readAllFiles(fsPath, fileFilter).map(
          (f) => normalizePath(f)
        );
        if (includeMode === "filesInFolder") {
          for (const child of children) {
            if (!lintFiles.includes(child)) {
              lintFiles.push(child);
              changed = true;
            }
          }
          for (let index = lintFiles.length - 1; index >= 0; index--) {
            const file = lintFiles[index];
            if (file.startsWith(normalizedPath) && !children.includes(file)) {
              lintFiles.splice(index, 1);
              changed = true;
            }
          }
        }
        for (const linter of options.linters) {
          const dataByFileName = dataByFileNameByLinterName[linter.name];
          for (const file of Object.keys(dataByFileName)) {
            if (file.startsWith(normalizedPath) && !children.includes(file)) {
              delete dataByFileName[file];
            }
          }
        }
      }
      return changed;
    }
    let watchTimeout;
    let paths = [];
    function onEvent(fsPath) {
      clearTimeout(watchTimeout);
      if (!paths.includes(fsPath)) {
        paths.push(fsPath);
      }
      watchTimeout = setTimeout(() => {
        let changed = false;
        for (const path2 of paths) {
          if (onChange(path2)) {
            changed = true;
          }
        }
        if (includeMode === "filesInFolder" && changed) {
          processFiles();
        }
        paths = [];
      }, 100);
    }
    if (process.platform === "linux") {
      watch(directory, {
        ignored: /node_modules/,
        ignoreInitial: true,
        persistent: false
      }).on("all", (event, fsPath) => {
        switch (event) {
          case "add":
            onEvent(fsPath);
            break;
          case "unlink":
            const parentDirPath = path.resolve(fsPath, "..");
            onEvent(parentDirPath);
            break;
        }
      });
    } else {
      fs.watch(
        directory,
        { persistent: false, recursive: true },
        (event, fileName) => {
          if (fileName) {
            onEvent(path.join(directory, fileName));
          }
        }
      );
    }
  }
  return {
    apply: "serve",
    name: servePluginName,
    buildStart() {
      workersByLinterName = createWorkerThreads(
        "serve",
        servePluginName,
        options.linters
      );
      for (const linterName of Object.keys(workersByLinterName)) {
        const worker = workersByLinterName[linterName];
        worker.on("message", (message) => onWorkerMessage(message, this));
      }
      const currentDirectory = process.cwd();
      watchDirectory(currentDirectory);
      if (includeMode === "filesInFolder") {
        lintFiles = readAllFiles(currentDirectory, fileFilter).map(
          (f) => normalizePath(f)
        );
        setTimeout(() => processFiles());
      }
    },
    configureServer(server) {
      devServer = server;
      devServer.middlewares.use(async (req, res, next) => {
        if (req.url === "/eslint.json") {
          const outputs = [];
          for (const linter of options.linters) {
            const output = await getFormattedOutput(linter);
            if (output) {
              outputs.push(output);
            }
          }
          res.setHeader("Access-Control-Allow-Origin", "*");
          res.setHeader("Content-Type", "application/json");
          res.write(JSON.stringify(outputs), "utf-8");
          res.end();
        } else {
          next();
        }
      });
    },
    getLinter(name) {
      return options.linters.find((l) => l.name === name);
    },
    load(id) {
      const file = normalizePath(id);
      try {
        if (options.injectFile) {
          if (file === normalizePath(options.injectFile)) {
            const content = fs.readFileSync(id);
            return content + clientJs;
          }
        } else if (injectedFile === null && !file.startsWith("node_modules/") && fs.existsSync(id) || file === injectedFile) {
          const content = fs.readFileSync(id);
          injectedFile = file;
          return content + clientJs;
        }
      } catch (ex) {
        console.warn(`Could not open file ${id}`, ex);
      }
      return null;
    },
    async transform(code, id) {
      if (!fileFilter(id) || includeMode === "filesInFolder") {
        return null;
      }
      const file = normalizePath(id);
      if (fs.existsSync(file)) {
        lintFiles.push(file);
      }
      const pluginContext = this;
      clearTimeout(processingTimeout);
      processingTimeout = setTimeout(
        () => processFiles().catch((ex) => pluginContext.error(ex)),
        1e3
      );
      return null;
    }
  };
}

function linterPlugin(options = {}) {
  const fileFilter = createFilter(
    options.include,
    options.exclude ?? /node_modules/
  );
  const plugins = [];
  if (!options.serve?.disable) {
    plugins.push(linterPluginServe(options, fileFilter));
  }
  if (!options.build?.disable || global.vitePluginLinter?.mode === "lintCommand") {
    plugins.push(linterPluginBuild(options, fileFilter));
  }
  return plugins;
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const defaultBuildOptions = {
  cache: false,
  fix: false
};
const defaultServeOptions = {
  cache: true,
  cacheLocation: "./node_modules/.cache/.eslintcache",
  fix: false
};
class EsLinter {
  constructor(options) {
    __publicField$1(this, "name", "EsLinter");
    __publicField$1(this, "eslint", null);
    __publicField$1(this, "formatter", null);
    __publicField$1(this, "options");
    if (options?.configEnv.command === "build") {
      this.options = { ...defaultBuildOptions, ...options.buildOptions };
    } else {
      this.options = { ...defaultServeOptions, ...options?.serveOptions };
    }
    if (this.options.clearCacheOnStart) {
      const cachePath = this.options.cacheLocation ?? ".eslintcache";
      if (fs.existsSync(cachePath)) {
        fs.unlinkSync(cachePath);
      }
    }
  }
  async format(results) {
    if (!this.eslint) {
      await this.loadLinter();
    }
    if (!this.formatter) {
      await this.loadFormatter();
    }
    return this.formatter.format(results);
  }
  async lintBuild(files) {
    return await this.lint(files);
  }
  async lintServe(files, output) {
    const reports = await this.lint(files);
    const result = {};
    for (const report of reports) {
      if (report.errorCount > 0 || report.warningCount > 0) {
        result[normalizePath(report.filePath)] = report;
      }
    }
    output(result);
  }
  async lint(files) {
    if (!this.eslint) {
      await this.loadLinter();
    }
    const lintFiles = [];
    for (const file of files) {
      if (!await this.eslint.isPathIgnored(file)) {
        lintFiles.push(file);
      }
    }
    const reports = await this.eslint.lintFiles(lintFiles);
    if (this.options.fix && reports) {
      ESLint.outputFixes(reports);
    }
    return reports;
  }
  async loadLinter() {
    const { clearCacheOnStart, formatter, ...esLintOptions } = this.options;
    const esLint = await loadESLint();
    this.eslint = new esLint(esLintOptions);
  }
  async loadFormatter() {
    switch (typeof this.options.formatter) {
      case "string":
        this.formatter = await this.eslint.loadFormatter(
          this.options.formatter
        );
        break;
      case "function":
        this.formatter = this.options.formatter;
        break;
      default:
        this.formatter = await this.eslint.loadFormatter("stylish");
    }
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const defaultOptions = {
  configFilePath: "tsconfig.json",
  noEmit: true
};
class TypeScriptLinter {
  constructor(options) {
    __publicField(this, "name", "TypeScriptLinter");
    __publicField(this, "formatHost", {
      getCanonicalFileName: (f) => f,
      getCurrentDirectory: process.cwd,
      getNewLine: () => "\n"
    });
    __publicField(this, "options");
    __publicField(this, "optionsLoadedFromFile", false);
    __publicField(this, "watchingFiles", []);
    __publicField(this, "watcher", null);
    this.options = { ...defaultOptions, ...options };
  }
  async format(results) {
    return ts.formatDiagnosticsWithColorAndContext(results, this.formatHost);
  }
  async lintBuild(files) {
    if (!this.optionsLoadedFromFile) {
      this.loadOptions();
    }
    const allFiles = files.concat(this.getCustomTypeRootFiles());
    const program = ts.createProgram(allFiles, this.options);
    return ts.getPreEmitDiagnostics(program);
  }
  lintServe(files, output) {
    if (!this.optionsLoadedFromFile) {
      this.loadOptions();
      this.watchingFiles = this.watchingFiles.concat(
        this.getCustomTypeRootFiles()
      );
    }
    if (files.some((f) => !this.watchingFiles.includes(f))) {
      this.watchingFiles = this.watchingFiles.concat(files).filter(onlyUnique);
      if (this.watcher) {
        this.watcher.close();
      }
      const host = ts.createWatchCompilerHost(
        this.watchingFiles,
        this.options,
        ts.sys,
        void 0,
        (diagnostic) => {
          if (diagnostic.category !== ts.DiagnosticCategory.Message && diagnostic.file) {
            output({
              [normalizePath(diagnostic.file.fileName)]: diagnostic
            });
          }
        },
        (diagnostic, newLine, options, errorCount) => {
          if (errorCount !== void 0 && errorCount <= 0) {
            output({});
          }
        }
      );
      this.watcher = ts.createWatchProgram(host);
    }
  }
  // Fix for ts api not respecting typeRoots option
  getCustomTypeRootFiles() {
    let files = [];
    if (this.options.typeRoots) {
      for (const root of this.options.typeRoots) {
        if (!root.includes("node_modules")) {
          files = files.concat(readAllFiles(root, (f) => f.endsWith(".d.ts")));
        }
      }
    }
    return files;
  }
  loadOptions() {
    this.optionsLoadedFromFile = true;
    if (!this.options.configFilePath) {
      return;
    }
    const configPath = path.resolve(process.cwd(), this.options.configFilePath);
    const configContents = fs.readFileSync(configPath).toString();
    const configResult = ts.parseConfigFileTextToJson(
      configPath,
      configContents
    );
    const compilerOptions = ts.convertCompilerOptionsFromJson(
      configResult.config["compilerOptions"] || {},
      process.cwd()
    );
    this.options = { ...compilerOptions.options, ...this.options };
  }
}

export { EsLinter, TypeScriptLinter, linterPlugin };
