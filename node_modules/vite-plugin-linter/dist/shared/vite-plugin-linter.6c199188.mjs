import { createWorkerThreads } from '../lintWorkerThread.mjs';
import fs from 'fs';
import path from 'path';

function normalizePath(id) {
  return path.relative(process.cwd(), id).split(path.sep).join("/");
}
function onlyUnique(value, index, self) {
  return self.indexOf(value) === index;
}
function readAllFiles(folder, filter) {
  let files = [];
  const children = fs.readdirSync(folder, { withFileTypes: true });
  for (const child of children) {
    const childName = folder + "/" + child.name;
    if (child.isDirectory()) {
      files = files.concat(readAllFiles(childName, filter));
    } else if (filter(childName)) {
      files.push(childName);
    }
  }
  return files;
}

const buildPluginName = "vite-plugin-linter-build";
function linterPluginBuild(options = {}, fileFilter) {
  const includeMode = options.build?.includeMode ?? "processedFiles";
  const transformedFiles = [];
  function getLintFiles(folder) {
    return readAllFiles(folder, fileFilter).map((f) => normalizePath(f));
  }
  return {
    apply: "build",
    enforce: "pre",
    name: buildPluginName,
    async buildEnd() {
      let files;
      if (includeMode === "filesInFolder") {
        files = getLintFiles(process.cwd());
      } else {
        files = transformedFiles;
      }
      const workersByLinterName = createWorkerThreads(
        "build",
        buildPluginName,
        options.linters
      );
      const lintTasks = [];
      for (const linterName of Object.keys(workersByLinterName)) {
        lintTasks.push(
          new Promise((resolve) => {
            const worker = workersByLinterName[linterName];
            worker.on("message", async (message) => {
              const linter = options.linters.find(
                (l) => l.name === message.linterName
              );
              resolve(await linter.format(message.result.build));
              worker.terminate();
            });
            worker.postMessage(files);
          })
        );
      }
      const results = (await Promise.all(lintTasks)).filter((r) => r);
      for (const result of results) {
        this.warn(result);
      }
      if (results.length > 0) {
        this.error("Linting failed, see above output");
      }
    },
    getLinter(name) {
      return options.linters.find((l) => l.name === name);
    },
    async lintFolder(folder) {
      const files = getLintFiles(folder);
      const outputLines = [];
      for (const linter of options.linters) {
        const result = await linter.lintBuild(files);
        const output = await linter.format(result);
        if (output) {
          outputLines.push(output);
        }
      }
      return outputLines;
    },
    transform(code, id) {
      if (!fileFilter(id) || includeMode === "filesInFolder") {
        return null;
      }
      transformedFiles.push(normalizePath(id));
      return null;
    }
  };
}

export { buildPluginName as b, linterPluginBuild as l, normalizePath as n, onlyUnique as o, readAllFiles as r };
