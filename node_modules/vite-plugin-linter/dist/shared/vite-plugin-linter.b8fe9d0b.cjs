'use strict';

const lintWorkerThread = require('../lintWorkerThread.cjs');
const fs = require('fs');
const path = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);

function normalizePath(id) {
  return path__default.relative(process.cwd(), id).split(path__default.sep).join("/");
}
function onlyUnique(value, index, self) {
  return self.indexOf(value) === index;
}
function readAllFiles(folder, filter) {
  let files = [];
  const children = fs__default.readdirSync(folder, { withFileTypes: true });
  for (const child of children) {
    const childName = folder + "/" + child.name;
    if (child.isDirectory()) {
      files = files.concat(readAllFiles(childName, filter));
    } else if (filter(childName)) {
      files.push(childName);
    }
  }
  return files;
}

const buildPluginName = "vite-plugin-linter-build";
function linterPluginBuild(options = {}, fileFilter) {
  const includeMode = options.build?.includeMode ?? "processedFiles";
  const transformedFiles = [];
  function getLintFiles(folder) {
    return readAllFiles(folder, fileFilter).map((f) => normalizePath(f));
  }
  return {
    apply: "build",
    enforce: "pre",
    name: buildPluginName,
    async buildEnd() {
      let files;
      if (includeMode === "filesInFolder") {
        files = getLintFiles(process.cwd());
      } else {
        files = transformedFiles;
      }
      const workersByLinterName = lintWorkerThread.createWorkerThreads(
        "build",
        buildPluginName,
        options.linters
      );
      const lintTasks = [];
      for (const linterName of Object.keys(workersByLinterName)) {
        lintTasks.push(
          new Promise((resolve) => {
            const worker = workersByLinterName[linterName];
            worker.on("message", async (message) => {
              const linter = options.linters.find(
                (l) => l.name === message.linterName
              );
              resolve(await linter.format(message.result.build));
              worker.terminate();
            });
            worker.postMessage(files);
          })
        );
      }
      const results = (await Promise.all(lintTasks)).filter((r) => r);
      for (const result of results) {
        this.warn(result);
      }
      if (results.length > 0) {
        this.error("Linting failed, see above output");
      }
    },
    getLinter(name) {
      return options.linters.find((l) => l.name === name);
    },
    async lintFolder(folder) {
      const files = getLintFiles(folder);
      const outputLines = [];
      for (const linter of options.linters) {
        const result = await linter.lintBuild(files);
        const output = await linter.format(result);
        if (output) {
          outputLines.push(output);
        }
      }
      return outputLines;
    },
    transform(code, id) {
      if (!fileFilter(id) || includeMode === "filesInFolder") {
        return null;
      }
      transformedFiles.push(normalizePath(id));
      return null;
    }
  };
}

exports.buildPluginName = buildPluginName;
exports.linterPluginBuild = linterPluginBuild;
exports.normalizePath = normalizePath;
exports.onlyUnique = onlyUnique;
exports.readAllFiles = readAllFiles;
